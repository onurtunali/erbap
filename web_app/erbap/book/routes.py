"""
Main API endpoints implemented with bluprints for viewing, searching and updating books.
"""
from flask import Blueprint, render_template
from erbap.review_scrapper import scraper
from datetime import datetime
import pandas as pd
from erbap import db
from sqlalchemy import text

book = Blueprint("book", __name__)
current_date = datetime.today().strftime("%Y-%m-%d")


@book.route("/view/<int:id>")
def view(id):
    select_query = text(
        """
        SELECT B.id, B.book_title, B.author_name, B.rating_score, B.book_description, B.year_published, B.genres, B.url, B.cover, R.date, R.capture_date, AVG(R.rating) AS avg_rating
        FROM books AS B LEFT JOIN reviews AS R ON B.id = R.book_id
        WHERE B.id = :id
        GROUP BY B.id, B.book_title, B.author_name, B.rating_score, B.book_description, B.year_published, B.genres, B.url, B.cover, R.date, R.capture_date
        ORDER BY R.date DESC
        LIMIT 1
    """
    )
    with db.session() as session:
        results = session.execute(select_query, {"id": id}).fetchall()
        results = [dict(r) for r in results]
        print(results, "RESULT TYPE", type(results[0]), results[0]["capture_date"])

    try:
        book_capture_date = results[0]["capture_date"].strftime("%Y-%m-%d")
    except:
        book_capture_date = None

    if book_capture_date != current_date:
        page_reviews = scraper.get_book_reviews(results[0]["url"], results[0]["id"])

        params = []

        for review in page_reviews:

            insert_query = text(
                """
                INSERT IGNORE INTO reviews VALUES (Null, :book_id, :date, :rating, :hash, :review_text, :capture_date)"""
            )

            param = {
                "book_id": review[0],
                "date": review[1],
                "rating": review[2],
                "hash": review[3],
                "review_text": review[4],
                "capture_date": review[5],
            }

            params.append(param)

        with db.session() as session:
            session.execute(insert_query, params)
            session.execute(
                text("""UPDATE reviews set capture_date = :cd where book_id = :id"""),
                {"cd": current_date, "id": id},
            )
            session.commit()

        print("new reviews are logged")

        with db.session() as session:
            results = session.execute(select_query, {"id": id}).fetchall()
            results = [dict(r) for r in results]

    book = {key: results[0][key] for key in results[0].keys()}
    genres = book["genres"].split(" ")
    genres = " | ".join(genres).title()
    genres = genres.replace("_", " ")
    book["genres"] = "| " + genres + " |"
    return render_template("view.html", book=book)


@book.route("/ratings/<int:id>")
def ratings(id):
    """
    API endpoint for grabing the most recent reviews and ratings given a book id.

    Args:
        id (int): The book id corresponding to the prime key of books table

    Returns:
        results (csv): Rating and reviews result generated by scrapper
    """
    with db.session() as session:
        select_query = """
            SELECT date, AVG(rating) AS rating
            FROM reviews
            WHERE book_id = :id
            GROUP BY date
            ORDER BY date DESC
            LIMIT 10
        """
        results = session.execute(select_query, {"id": id}).fetchall()
    # results = [{key: result[key] for key in result.keys()} for result in results]
    # results = [dict(row) for row in ]

    results = pd.DataFrame(
        {
            "date": [result[0] for result in results],
            "rating": [result[1] for result in results],
        }
    )
    results = results.sort_values("date").to_csv(index=False)
    return results


# # @bp.route("/create", methods=("GET", "POST"))
# # def create():
# #     if request.method == "POST":
# #         title = request.form["title"]
# #         body = request.form["body"]
# #         error = None

# #         if not title:
# #             error = "Title is required."

# #         if error is not None:
# #             flash(error)
# #         else:
# #             db = get_db()
# #             db.execute(
# #                 "INSERT INTO post (title, body, author_id)" " VALUES (?, ?, ?)",
# #                 (title, body, g.user["id"]),
# #             )
# #             db.commit()
# #             return redirect(url_for("blog.index"))

# #     return render_template("blog/create.html")


# # def get_post(id, check_author=True):
# #     post = (
# #         get_db()
# #         .execute(
# #             "SELECT p.id, title, body, created, author_id, username"
# #             " FROM post p JOIN user u ON p.author_id = u.id"
# #             " WHERE p.id = ?",
# #             (id,),
# #         )
# #         .fetchone()
# #     )

# #     if post is None:
# #         abort(404, f"Post id {id} doesn't exist.")

# #     if check_author and post["author_id"] != g.user["id"]:
# #         abort(403)

# #     return post


# # @bp.route("/<int:id>/update", methods=("GET", "POST"))
# # def update(id):
# #     post = get_post(id)

# #     if request.method == "POST":
# #         title = request.form["title"]
# #         body = request.form["body"]
# #         error = None

# #         if not title:
# #             error = "Title is required."

# #         if error is not None:
# #             flash(error)
# #         else:
# #             db = get_db()
# #             db.execute(
# #                 "UPDATE post SET title = ?, body = ?" " WHERE id = ?", (title, body, id)
# #             )
# #             db.commit()
# #             return redirect(url_for("blog.index"))

# #     return render_template("blog/update.html", post=post)


# # @bp.route("/<int:id>/delete", methods=("POST",))
# # def delete(id):
# #     get_post(id)
# #     db = get_db()
# #     db.execute("DELETE FROM post WHERE id = ?", (id,))
# #     db.commit()
# #     return redirect(url_for("blog.index"))
